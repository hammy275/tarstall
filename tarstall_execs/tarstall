#!/usr/bin/python3

"""tarstall: A package manager for managing archives
    Copyright (C) 2020  hammy3502

    tarstall is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    tarstall is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with tarstall.  If not, see <https://www.gnu.org/licenses/>."""

import sys
import os
import argparse
import sys
import getpass
import shutil

sys.path.insert(1, os.path.abspath(os.path.expanduser("{}/..".format(os.path.dirname(__file__)))))

import config
import generic
import prog_manage
import re
from subprocess import call

mode = config.read_config("Mode")

if mode == "gui":
    try:
        import tkinter
        del tkinter
        try:
            import PySimpleGUI as sg
            sg.theme("Black")
        except ImportError:
            config.mode = "cli"
            mode = "cli"
            print("PySimpleGUI not installed! Defaulting to cli mode...")
    except ImportError:
        config.mode = "cli"
        mode = "cli"
        print("Tkinter not installed! Defaulting to cli mode...")

def gui_loop():
    """Main Loop for GUI."""
    to_disable = ["install", "install_browse", "dirinstall", "dirinstall_browse", "gitinstall",
    "gitinstall_browse", "remove", "manage"]
    layout = [
        [sg.Text("Select an option:")],
        [sg.Radio("Install: ", "Todo", default=True, enable_events=True, key="should_install"), sg.InputText(key="install"), sg.FileBrowse(key="install_browse")],
        [sg.Radio("Install Directory: ", "Todo", enable_events=True, key="should_dirinstall"), sg.InputText(key="dirinstall", disabled=True), sg.FolderBrowse(disabled=True, key="dirinstall_browse")],
        [sg.Radio("Gitinstall: ", "Todo", enable_events=True, key="should_gitinstall"), sg.InputText(key="gitinstall", disabled=True), sg.FileBrowse(disabled=True, key="gitinstall_browse")],
        [sg.Radio("Remove: ", "Todo", enable_events=True, key="should_remove"), sg.Combo(prog_manage.list_programs(), key="remove", disabled=True)],
        [sg.Radio("Erase tarstall", "Todo", enable_events=True, key="should_erase")],
        [sg.Radio("Update tarstall", "Todo", enable_events=True, key="should_update")],
        [sg.Radio("Manage: ", "Todo", enable_events=True, key="should_manage"), sg.Combo(prog_manage.list_programs(), key="manage", disabled=True)],
        [sg.Radio("Configure tarstall", "Todo", enable_events=True, key="should_configure")],
        [sg.Radio("Upgrade all programs that can be upgraded", "Todo", enable_events=True, key="should_update_programs")],
        [sg.Button("Go"), sg.Button("Exit")],
        [sg.ProgressBar(100, key="bar")],
        [sg.Text(" "*100, key="status_area")]
    ]
    window = sg.Window('tarstall-gui', layout=layout)
    while True:
        event, values = window.Read()
        config.install_bar = window.Element("bar")
        config.output_area = window.Element("status_area")
        config.install_bar.UpdateBar(0)
        if event in (None, "Exit"):
            sys.exit(0)
        elif event == "Go":
            if values["should_install"]:
                status = parse_args(["--install", values["install"]])
            elif values["should_dirinstall"]:
                status = parse_args(["--dirinstall", values["dirinstall"]])
            elif values["should_gitinstall"]:
                status = parse_args(["--gitinstall", values["gitinstall"]])
            elif values["should_remove"]:
                status = parse_args(["--remove", values["remove"]])
            elif values["should_erase"]:
                status = parse_args(["--erase"])
            elif values["should_update"]:
                status = parse_args(["--update"])
            elif values["should_manage"]:
                status = parse_args(["--manage", values["manage"]])
            elif values["should_configure"]:
                status = parse_args(["--config"])
            elif values["should_update_programs"]:
                status = parse_args(["--update-programs"])
            if status == "Locked":
                generic.pprint("tarstall is locked! You can unlock it, but if another instance of tarstall is running, things will break!")
                ul = generic.get_input("Would you like to unlock tarstall? Only do this if no other instances of tarstall are running!", ['y', 'n'], 'n',
                ["Yes", "No"])
                if ul == 'y':
                    parse_args(["--remove-lock"])
                    generic.pprint("tarstall unlocked! Please specify what you would like to do again!")
                else:
                    sys.exit(1)
            else:
                config.install_bar.UpdateBar(100)
        else:
            for o in to_disable:
                window.Element(o).Update(disabled=True)
            if event == "should_install":
                window.Element("install").Update(disabled=False)
                window.Element("install_browse").Update(disabled=False)
            elif event == "should_dirinstall":
                window.Element("dirinstall").Update(disabled=False)
                window.Element("dirinstall_browse").Update(disabled=False)
            elif event == "should_gitinstall":
                window.Element("gitinstall").Update(disabled=False)
                window.Element("gitinstall_browse").Update(disabled=False)
            elif event == "should_remove":
                window.Element("remove").Update(disabled=False)
            elif event == "should_manage":
                window.Element("manage").Update(disabled=False)


def process_update_status(status):
    """Show End User Status from prog_manage.update().

    Args:
        status (str): Status from prog_manage.update()

    """
    if status == "No git":
        generic.pprint("git isn't installed, please install it!")
        exit_code = 1
    elif status == "No requests":
        generic.pprint("requests isn't installed, please install it!")
        exit_code = 1
    elif status == "Newer version":
        generic.pprint("The installed version is newer than the one found online!")
    elif status == "No update":
        generic.pprint("No update was found!")
    elif status == "Failed":
        generic.pprint("tarstall update failed!")
        exit_code = 1
    elif status == "No internet":
        generic.pprint("Failed to connect to the internet!")
        exit_code = 1
    elif status == "Updated":
        generic.pprint("tarstall successfully updated!")
    elif status == "Repaired":
        generic.pprint("tarstall successfully repaired!")
        config.unlock()
        sys.exit(0)


def repair_tarstall():
    yn = generic.get_input("Would you like to repair tarstall? This process does require internet access!", ['y', 'n'], 'n', ["Yes", "No"])
    if yn != 'y':
        generic.ppause("Repairs not attempted!")
    else:
        status = prog_manage.repair_tarstall()
        if status == "Updated":
            status = "Repaired"
        process_update_status(status)


def possibly_repair_db(possibly_corrupt=False):
    if not possibly_corrupt:
        msg = """
#########################################
#################WARNING#################
#########################################
WARNING: This feature should ONLY be used if your database is corrupt in some manner, as information such as the following can and will be lost:

- Upgrade scripts/post-upgrade scripts will no longer be linked to their respective programs!
- The program type (default vs. git-installed vs. single-file) may be mis-recognized/misconfigured!
- tarstall will assume you're on the master branch! If you're currently on beta, you will have to wait until the master branch surpasses your current version, or you have to switch to the beta branch after repairs!
- Any update URLs programs have will no longer have them!

If ~/.tarstall, ~/.tarstall/bin or ~/.tarstall/.bashrc were tampered with, than database recovery may have invalid information mixed in!

Are you sure you would like to attempt repairing?
#########################################"""
    yn = generic.get_input(msg, ['y', 'n'], 'n', ["Yes", "No"])
    if yn != 'y':
        generic.ppause("Repairs not attempted!")
    else:
        yn = generic.get_input("Are you SURE you would like to attempt database repair?", ['y', 'n'], 'n', ["Yes", "No"])
        if yn != 'y':
            generic.ppause("Repairs not attempted!")
        else:
            yn = generic.get_input("If you proceed, (post-)upgrade script references will be lost, and programs may be misconfigured! Are you SURE you would like to continue?", ['y', 'n'], 'n', ["Yes", "No"])
            if yn != 'y':
                generic.ppause("Repairs not attempted!")
            else:
                prog_manage.repair_db()
                generic.ppause("Database repair complete!")
                config.unlock()
                sys.exit(0)


def wget_wizard(program):
    if not config.check_bin("wget"):
        generic.ppause("You must have 'wget' installed to use this feature!")
        return
    while True:
        if config.db["programs"][program]["update_url"]:
            r_msg = "\nr - Remove URL to download a copy of this program when upgraded."
        else:
            r_msg = ""
        msg = """
Select an option:
a - Add a URL to download a fresh copy of this program when upgraded{r_msg}
e - Return to program management""".format(r_msg=r_msg)
        options = ['a', 'e']
        gui_options = ["Add a URL", "Return to Program Management"]
        if r_msg:
            options.append('r')
            gui_options.append("Remove URL from Program")
        ans = generic.get_input(msg, options, 'e', gui_options)
        if ans == 'a':
            new_url = ""
            while re.match(r"https://\w.\w", new_url) is None or new_url == "":
                new_url = generic.ask("Please enter a URL that points directly to a .tar.gz that contains" + 
                "a full-copy of the program to install when upgrading. Type 'c' or 'cancel' to cancel: ")
                if new_url.lower() == 'c' or new_url.lower() == "cancel":
                    return
            prog_manage.add_upgrade_url(program, new_url)
            generic.pprint("URL added successfully!")
        elif ans == 'r' and r_msg:
            prog_manage.remove_update_url(program)
            generic.pprint("Upgrade URL successfully removed from program!")
        elif ans == 'e':
            return



def git_wizard(program):
    """Extra management for a program installed through git.

    Args:
        program (str): Name of program to manage

    """
    msg = """
Select an option:
u - Update program from currently configured branch
b - Reset repository and change branches (WARNING: This will remove everything inside this program's directory!)
e - Exit Git Wizard."""
    ans = generic.get_input(msg, ['u', 'b', 'e'], 'e', ["Update", "Change branch", "Exit"])
    if ans == 'u':
        status = prog_manage.update_git_program(program)
        if status == "Success":
            generic.pprint("Update successful!")
        elif status == "No git":
            generic.pprint("Git isn't installed, please install it!")
        elif status == "Error updating":
            generic.pprint("An error occured while attempting to update {}.".format(program))
    elif ans == 'b':
        branch = generic.ask("Enter branch to switch to: ")
        status = prog_manage.change_git_branch(program, branch)
        if status == "Success":
            generic.pprint("Branch change successful!")
        elif status == "No git":
            generic.pprint("Git isn't installed, please install it!")
        elif status == "Error changing":
            generic.pprint("An error occured while attempting to change the branches of {}.".format(program))
    elif ans == 'e':
        return



def branch_wizard():
    """Switch Branches."""
    msg = """\n\n
####WARNING####
WARNING: You are changing branches of tarstall!
Changing from master to beta means you may receive updates that contain bugs, some extremely severe!
Changing from beta to master means you will either HAVE ALL OF YOUR tarstall PROGRAMS DELETED
or you will have to STAY ON THE UPDATE YOU CURRENTLY HAVE UNTIL MASTER CATCHES UP!

Switching branches will trigger an immediate update of tarstall!
###############

Select a branch:
m - Master branch. Less bugs, more stable, wait for updates.
b - Beta branch. More bugs, less stable, updates ASAP.
E - Exit branch wizard and don't change branches."""
    ans = generic.get_input(msg, ['m', 'b', 'e'], 'e', ["Master", "Beta", "Exit"])
    if ans == 'e':
        generic.pprint("Not changing branches!")
        return
    elif ans == 'm' and config.db["version"]["branch"] == "master":
        generic.pprint("Already on the master branch, not switching!")
        return
    elif ans == 'b' and config.db["version"]["branch"] == "beta":
        generic.pprint("Already on the beta branch, not switching!")
        return
    else:
        check = generic.ask('Type "YES" (without the quotes) to confirm the branch switch! ')
        if check != "YES":
            generic.pprint("Cancelling branch switch.")
            return
        else:
            if ans == "m":
                branch = "master"
                should_reset = generic.get_input("Would you like to reset tarstall or wait for master to update past where you are? [r/W]",
                ["r", "w"], "w", ["Reset", "Wait"])
            elif ans == "b":
                branch = "beta"
                should_reset = "w"
            status = prog_manage.change_branch(branch, should_reset == "r")
            if status == "Success":
                generic.pprint("Successfully switched to the beta branch!")
                return
            elif status == "Bad branch":
                generic.pprint("Invalid branch specified!")
                return
            elif status == "Reset":
                generic.pprint("Successfully switched to the master branch and reset tarstall!" \
                " Please run tarstall again to finish the downgrade process!")
                config.unlock()
                sys.exit(0)
            elif status == "Waiting":
                generic.pprint("Successfully switched to the master branch!" \
                " When the master branch is a newer version than the beta one, the next update will bring you up to master.")
                return


def configure():
    """Change tarstall Options."""
    while True:
        options = [
            {"shorthand": 'au', "gui-label": "Autoupdate", "description": "Enable/disable the ability to install updates when tarstall is run. Currently {au}."},
            {"shorthand": 'v', "gui-label": "Verbosity", "description": "Enable/disable verbose mode, showing more output when tarstall commands are run. Currently {v}."},
            {"shorthand": 'b', "gui-label": "Change Branches", "description": "Swap branches in tarstall. Allows you to get updates sooner at the cost of possible bugs. Current branch: {b}."},
            {"shorthand": 'm', "gui-label": "Change Interaction Mode", "description": "Whether or not to use the GUI for tarstall. Currently {gui}."},
            {"shorthand": 's', "gui-label": "Skip Questions", "description": "Whether or not to skip ending questions and confirmations. Currently {skip}."},
            {"shorthand": 'u', "gui-label": "Update URL-Attatched Programs", "description": "Whether or not to update programs that have a URL attatched to them for updating. Currently {url}."},
            {"shorthand": 'c', "gui-label": "Press ENTER messages (CLI only)", "description": "Whether or not to have some messages have you \"Press ENTER to continue...\". Currently {skipenter}."},
            {"shorthand": 'rd', "gui-label": "Attempt Database Repair", "description": "Attempt to repiar tarstall's database. Only use as a last resort!"},
            {"shorthand": 'rt', "gui-label": "Attempt tarstall Repair", "description": "Attempt to repiar tarstall itself."},
            {"shorthand": 'w', "gui-label": "Skip Missing Dependency Warnings", "description": "Whether or not to skip missing dependency warning. Currently {depen}"},
            {"shorthand": 'e', "gui-label": "Exit", "description": "Exit tarstall", "is-default": True},
        ]
        replacements = [
            {"{au}": generic.endi(config.read_config("AutoInstall"))},
            {"{v}": generic.endi(config.read_config("Verbose"))},
            {"{b}": config.db["version"]["branch"]},
            {"{gui}": generic.endi(config.read_config("Mode") == "gui")},
            {"{skip}": generic.endi(config.read_config("SkipQuestions"))},
            {"{url}": generic.endi(config.read_config("UpdateURLPrograms"))},
            {"{skipenter}": generic.endi(config.read_config("PressEnterKey"))},
            {"{depen}": generic.endi(config.read_config("WarnMissingDeps"))}
        ]
        option = generic.easy_get_action(options, replacements)
        if option == 'au':
            if not prog_manage.can_update:
                generic.pprint("requests isn't installed, so AutoInstall cannot be enabled!")
            else:
                key = "AutoInstall"
        elif option == 'v':
            key = "Verbose"
        elif option == 'b':
            branch_wizard()
            key = None
        elif option == 'm':
            if config.read_config("Mode") == "cli":
                config.change_config("Mode", "change", "gui")
                prog_manage.create_desktop(None, "tarstall", "~/.tarstall/tarstall_execs/tarstall", 
                "Run tarstall's GUI", "False", ["Utility"], "", "~/.tarstall/tarstall_execs/")
                generic.ppause("Changed to GUI mode! Restart tarstall to confirm your changes!")
            else:
                config.change_config("Mode", "change", "cli")
                os.remove(config.full("~/.local/share/applications/tarstall/tarstall.desktop"))
                generic.ppause("Changed to CLI mode! Restart tarstall to confirm your changes!")
            key = None
        elif option == 's':
            key = "SkipQuestions"
        elif option == 'u':
            key = "UpdateURLPrograms"
        elif option == 'c':
            key = "PressEnterKey"
        elif option == 'rd':
            possibly_repair_db()
            key = None
        elif option == 'rt':
            repair_tarstall()
            key = None
        elif option == 'w':
            key = "WarnMissingDeps"
        elif option == 'e':
            return
        if key is not None:
            new_value = config.change_config(key, "flip")
            generic.ppause("\n{key} mode {value}!".format(key=key, value=generic.endi(new_value)))


def pathify(program):
    """Pathify CLI Function.

    Args:
        program (str): Name of program to PATHify

    """
    status = prog_manage.pathify(program)
    if status == "Complete":
        generic.ppause("Program added to PATH!")
    elif status == "Already there":
        generic.ppause("Program already added to PATH!")


def binlink(program):
    """Binlink CLI Function.

    Args:
        program (str): Name of program to create binlinks for

    """
    yn = 'y'
    while yn != 'n':
        file_chosen = generic.file_browser('~/.tarstall/bin/' + program + '/')
        if file_chosen is None:
            return
        status = prog_manage.add_binlink(file_chosen, program)
        if status == "Already there":
            generic.ppause("Binlink not added since it already exists!")
        yn = generic.get_input('Would you like to add another binlink?', ['y', 'n'], 'n')


def desktop_wizard(program, is_single=False):
    """Desktop Creation Wizard.

    Args:
        program (str): Program to create .desktop file of

    """
    if is_single:
        program_file = program
    else:
        program_file = generic.file_browser(config.full('~/.tarstall/bin/' + program + '/'))
    if program_file is None:
        return
    comment = "/"
    while not comment.replace(" ", "").isalnum() and comment != "":
        comment = generic.ask("Please input a comment for the application: ")
    icon = ";"
    while not icon.replace("-", "").replace("_", "").replace("/", "").isalnum() and icon != "":
        icon = generic.ask("Enter the path to an icon, the name of the icon, or press ENTER for no icon! ")
    terminal = generic.get_input("Should this program launch a terminal to run it in?", ['y', 'n'], 'n', ["Yes", "No"])
    if terminal.lower() == 'y':
        should_terminal = "True"
    else:
        should_terminal = "False"
    name = "/"
    while not name.replace(" ", "").isalnum() and name != "":
        name = generic.ask("Please enter a name: ")
    if name == "":
        name = program
    ans = " "
    chosen_categories = []
    categories = ["audio", "video", "development", "education", "game", "graphics", "network", "office",
                    "science", "settings", "system", "utility", "end"]
    while ans.lower() != "end":
        msg = "Please enter categories, one at a time, from the list of .desktop categories below (defaults to " \
                "Utility). Type \"end\" to end category selection. \n" + ", ".join(categories) + "\n"
        ans = generic.get_input(msg, categories, "utility")
        if ans.capitalize() in chosen_categories or ans == "end":
            pass
        else:
            ans = ans.capitalize()
            chosen_categories.append(ans)
    status = prog_manage.create_desktop(program, name, program_file, comment, should_terminal,
                                        chosen_categories, icon)
    if status == "Created":
        generic.ppause(".desktop file successfully created!")
    elif status == "Already exists":
        generic.ppause(".desktop file already exists!")


def install_wrap_up(program, is_single=False):
    """End of Install.

    Runs at the end of an install to ask users about different "shortcut" creations/PATH creation

    Args:
        program (str): Name of program

    """
    if not config.read_config("SkipQuestions"):
        if is_single:
            yn = generic.get_input('Would you like to create the binlink for this program?', ['y', 'n'], 'n', ["Yes", "No"])
            if yn == 'y':
                prog_manage.add_binlink(program, program)
                generic.ppause("Binlink created!")
            yn = generic.get_input('Would you like to create the desktop file for this program?', ['y', 'n'], 'n', ["Yes", "No"])
            if yn == 'y':
                desktop_wizard(program, True)
        else:
            yn = generic.get_input('Would you like to add the program to your PATH?', ['y', 'n'], 'y', ["Yes", "No"])
            if yn == 'y':
                pathify(program)
            yn = generic.get_input('Would you like to create a binlink?', ['y', 'n'], 'n', ["Yes", "No"])
            if yn == 'y':
                binlink(program)
            yn = generic.get_input('Would you like to create a desktop file?', ['y', 'n'], 'n', ["Yes", "No"])
            if yn == 'y':
                desktop_wizard(program)
    generic.pprint("Installation complete!")


def update_program_gui(program):
    """Update a Program and Print Result to User.

    Args:
        program (str): Program to update.

    """
    status = prog_manage.update_program(program, True)
    if status == "Success":
        generic.ppause("Program upgrading successful!")
    elif status == "No update":
        generic.ppause("Program is already up to date!")
    elif status == "No git":
        generic.ppause("Git not installed, please install it!")
    elif status == "Error updating":
        generic.ppause("Error while upgrading through git!")
    elif status == "No script":
        generic.ppause("Upgrade script no longer exists! The update script reference has been removed!")
    elif status == "Script error":
        generic.ppause("Error while executing the supplied upgrade script!")
    elif status == "OSError":
        generic.ppause("Shell not specified! Please specify one at the top of the supplied script (ex. #!/bin/sh)")
    elif status == "No wget":
        generic.ppause("Wget is not installed!")
    elif status == "Wget error":
        generic.ppause("An error occured while downloading the archive!")
    elif status == "Install error":
        generic.ppause("An error occured while installing the program!")
    elif status == "Does not update":  # Can only be reached through -q, so no need to ppause here
        generic.pprint("Program does not have any way of updating!")


def manage(program):
    """Manage Installed Program.

    Args:
        program (str): Internal name of program to manage

    """
    if not program in config.db["programs"]:
        generic.pprint("{} not installed!".format(program))
        return
    if config.db["programs"][program]["install_type"] == "single":
        options = [
            {"shorthand": 'b', "gui-label": "Create binlink", "description": "Create binlink for {program}"}, 
            {"shorthand": 'n', "gui-label": "Rename", "description": "Rename {program}"},
            {"shorthand": 'u', "gui-label": "Uninstall", "description": "Uninstall {program}"},
            {"shorthand": 'r', "gui-label": "Remove binlink", "description": "Remove binlink for {program}"},
            {"shorthand": 'd', "gui-label": "Create .desktop file", "description": "Create the .desktop file for {program}"},
            {"shorthand": 'rd', "gui-label": "Remove .desktop file", "description": "Remove the .desktop file for {program}"},
            {"shorthand": 's', "gui-label": "Launch shell", "description": "Launch a shell inside {program}'s directory"},
            {"shorthand": 'us', "gui-label": "Add upgrade script", "description": "Add {us} script for {program}"}
        ]
    else:
        options = [
            {"shorthand": 'b', "gui-label": "Create binlinks", "description": "Create binlinks for {program}"},
            {"shorthand": 'p', "gui-label": "Add to PATH", "description": "Add {program} to PATH"},
            {"shorthand": 'n', "gui-label": "Rename", "description": "Rename {program}"},
            {"shorthand": 'u', "gui-label": "Uninstall", "description": "Uninstall {program}"},
            {"shorthand": 'r', "gui-label": "Remove all binlinks and PATHs", "description": "Remove all binlinks + PATHs for {program}"},
            {"shorthand": 'd', "gui-label": "Create .desktop file", "description": "Create a .desktop file for {program}"},
            {"shorthand": 'rd', "gui-label": "Remove .desktop file", "description": "Remove a .desktop file for {program}"},
            {"shorthand": 's', "gui-label": "Launch shell", "description": "Launch a shell inside {program}'s directory"},
            {"shorthand": 'us', "gui-label": "Add upgrade script", "description": "Add {us} script for {program}"}
        ]
    can_update = config.db["programs"][program]["install_type"] == "git" or config.db["programs"][program]["post_upgrade_script"] or config.db["programs"][program]["update_url"]
    is_git = config.db["programs"][program]["install_type"] == "git"
    is_single = config.db["programs"][program]["install_type"] == "single"
    is_wget = config.db["programs"][program]["update_url"]
    if is_git:
        options.append({"shorthand": 'g', "gui-label": "Manage git settings", "description": "Manage git-related settings for {program}"})
        us = "a post-upgrade"
    else:
        options.append({"shorthand": 'w', "gui-label": "Add/remove update URL", "description": "Add/remove an update URL for {program}"})
        if is_wget:
            us = "a post-upgrade"
        else:
            us = "an upgrade"
    if can_update:
        options.append({"shorthand": 'q', "gui-label": "Upgrade program", "description": "Upgrade {program}"})
    options.append({"shorthand": 'e', "gui-label": "Exit", "description": "Exit program management", "is-default": True})
    while True:
        option = generic.easy_get_action(options, [{"{program}": program}, {"{us}": us}])
        if option == 'b':
            if is_single:
                prog_manage.add_binlink(program, program)
                generic.ppause("Binlink created!")
            else:
                binlink(program)
        elif option == 'p' and not is_single:
            pathify(program)
        elif option == 'n':
            new_name = "!"
            while not new_name.replace("_", "").replace("-", "").isalnum():
                new_name = generic.ask("Please enter the name you would like to change this program to: ")
                if not new_name.replace("_", "").replace("-", "").isalnum():
                    generic.pprint("Alphanumeric characters, dashes, and underscores only, please!")
            r_program = prog_manage.rename(program, new_name)
            if r_program is None:
                generic.pprint("Specified program name is already taken by another program!")
            else:
                program = r_program
        elif option == 'u':
            prog_manage.uninstall(program)
            break
        elif option == 'r':
            status = prog_manage.remove_paths_and_binlinks(program)
            if status == "Complete":
                if is_single:
                    generic.ppause("Binlink removal complete!")
                else:
                    generic.ppause("Removal of PATHs and binlinks complete!")
            elif status == "None exist":
                if is_single:
                    generic.ppause("The program doesn't have their binlink assigned!")
                else:
                    generic.ppause("The program isn't added to PATH and has no binlinks, so none removed!")
        elif option == 'd':
            desktop_wizard(program, is_single)
        elif option == 'rd':
            if is_single:
                prog_manage.remove_desktop(program, "{p}-{p}".format(p=program))
            else:
                msg = "Desktops:\n"
                for d in config.db["programs"][program]["desktops"]:
                    msg += d + "\n"
                inp = "/ choose desktop"
                while not (inp in config.db["programs"][program]["desktops"]) and inp != "exit":
                    inp = generic.ask(msg + "\nPlease enter the desktop you would like to remove or type \"exit\" to exit: ")
                if inp != "exit":
                    prog_manage.remove_desktop(program, inp)
        elif option == 's':
            if mode == "gui":
                generic.pprint("This feature can only be used from the command line version of tarstall!")
            else:
                generic.pprint("When you exit the shell, you will be returned to here.")
                os.chdir(config.full("~/.tarstall/bin/" + program + "/"))
                if config.get_shell_file() == ".zshrc":
                    call(["/bin/zsh"])
                elif "fish" in config.get_shell_file():
                    call(["/usr/bin/fish"])
                else:
                    call(["/bin/bash"])
        elif option == 'g' and is_git:
            git_wizard(program)
        elif option == 'w' and not is_git:
            wget_wizard(program)
        elif option == 'q' and can_update:
            update_program_gui(program)
        elif option == 'us':
            msg = """
Please input the path to a script you would like to run to upgrade an installed program.
Note: The script will be run inside your program's directory.
Leave blank to de-link the script from the program.
Warning: The shell must be specified at the top of the file (ie. "#!/bin/sh")
"""
            status = prog_manage.update_script(program, generic.ask_file(msg))
            if status == "Success":
                generic.ppause("Update script added successfully!")
            elif status == "Bad path":
                generic.ppause("Script specified does not exist!")
            elif status == "Wiped":
                generic.ppause("Successfully removed post upgrade script.")
        elif option == 'e':
            break


def fts_status(status):
    """Process First Time Setup Status.

    Args:
        status (str): Status string from first time setup

    Returns:
        int: Exit code to exit tarstall with

    """
    if status == "Success":
        generic.pprint('First time setup complete!')
        generic.pprint('Please run the command "source ~/{}" or restart your terminal.'.format(config.read_config("ShellFile")))
        generic.pprint('Afterwards, you may begin using tarstall with the "tarstall" command!')
        return 0
    elif status == "Already installed":
        generic.pprint("tarstall is already installed on your system! Cancelling installation.")
        return 1
    elif status == "Bad copy":
        generic.pprint("A file was attempting to be copied, but was deleted during the process! Installation halted.")
        return 1
    elif status == "Unsupported shell":
        generic.pprint("#"*30 + "\nWARNING: Your shell is not supported by tarstall! If your shell supports 'source' and 'alias' like bash does," + 
        " please point your shell's equivalent of .bashrc to ~/.tarstall/.bashrc. If not, anything related to PATHs and binlinks" + 
        " will NOT work, and you will have to run tarstall from the ~/.tarstall/tarstall_execs directory, unless you point to it yourself!\n" + 
        "#"*30 + "\nFirst time setup has otherwise been complete!")
        return 1
    else:
        return

def parse_args(args=None):
    """Argument Parsing.

    Parses arguments and runs tarstall startup.

    """
    exit_code = 0
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-i', "--install", help="Install a .tar.gz, .tar.xz, or .zip")
    group.add_argument('-d', "--dirinstall", help="Install a directory")
    group.add_argument('-g', '--gitinstall', help="Install by retrieving a git repository")
    group.add_argument('-s', '--singleinstall', help="Install a program stored as a single executable file")
    group.add_argument('-r', "--remove", help="Remove an insatlled program")
    group.add_argument('-l', "--list", help="List installed programs", action="store_true")
    group.add_argument('-f', "--first", help="Run first time setup", action="store_true")
    group.add_argument('-e', "--erase", help="Delete tarstall from your system", action="store_true")
    group.add_argument('-v', "--verbose", help="Toggle verbose mode", action="store_true")
    group.add_argument('-u', '--update', help="Update tarstall if an update is available", action="store_true")
    group.add_argument('-m', '--manage', help="Manage an installed program")
    group.add_argument('-k', '--remove-lock', help="Remove tarstall lock file (only do this if tarstall isn't already "
                                                "running)", action="store_true")
    group.add_argument('-c', '--config', help="Change tarstall options", action="store_true")
    group.add_argument('-q', '--update-programs', help="Update programs that can be updated, or a single program if supplied.", nargs='?', const=True, type=str)
    if args is None:
        args = parser.parse_args()
    else:
        args = parser.parse_args(args)

    status = prog_manage.tarstall_startup(start_fts=args.first, del_lock=args.remove_lock)

    fts_status(status)

    did_fts = args.first

    if status == "Locked":
        if mode == "cli":
            generic.pprint("Another instance of tarstall is probably running! Execution halted!")
            sys.exit(1)
        elif mode == "gui":
            return "Locked"

    elif status == "Unlocked":
        generic.pprint("tarstall unlocked!")
        sys.exit()

    elif status == "Not installed":
        yn = generic.get_input('tarstall is not installed on your system. Would you like to install it?',
                                ['y', 'n'], 'y')
        if yn == 'y':
            status = prog_manage.first_time_setup()
            exit_code = fts_status(status)
            did_fts = True
        else:
            generic.pprint('tarstall not installed.')
            config.unlock()
            sys.exit(1)
    
    elif status == "Root":
        generic.pprint("Don't use sudo unless you want your programs installed for root and only root!")
    
    elif status == "Old":
        generic.pprint("You are using an extremely outdated version of tarstall, please update manually!")
        sys.exit(1)
    
    elif status == "Old upgrade":
        generic.ppause("You are upgrading from a VERY old version of tarstall. Upgradiing will wipe your database! To upgrade: ")
        prog_manage.tarstall_startup(start_fts=args.first, del_lock=args.remove_lock, old_upgrade=True)
    
    elif status == "DB Broken":
        yn = generic.get_input("Your tarstall database is corrupt! Would you like to attempt to fix it? You will lose things such as program update URLs, and some other things!", ['y', 'n'], 'n', ["Yes", "No"])
        if yn != 'y':
            config.unlock()
            generic.pprint("Not repairing DB.")
            sys.exit(1)
        else:
            prog_manage.repair_db()
            config.unlock()
            sys.exit(0)

    if status == "Missing Deps" and config.read_config("WarnMissingDeps"):
        yn = generic.get_input("You are missing some dependencies to allow full usage of tarstall! Would you like to re-run the installer to install the dependencies?", ['y', 'n'], 'y', ["Yes", "No"])
        if yn == 'y':
            exit_code = 1
            status = prog_manage.reinstall_deps()
            if status == "Success":
                generic.pprint("Successfully re-installed dependencies!")
                exit_code = 0
            elif status == "No wget":
                generic.pprint("You don't have wget, please install it!")
            elif status == "Wget error":
                generic.pprint("An error occured while trying to obtain the tarstall installer. Are you connected to the internet?")
            elif status == "Installer error":
                generic.pprint("An error occured while running the installer")
            config.unlock()
            sys.exit(exit_code)

    if args.install is not None:
        overwrite = False
        status = prog_manage.pre_install(args.install)
        if status == "Bad file":
            generic.pprint("The specified file does not exist!")
            exit_code = 1
        elif status == "Application exists":
            reinstall = generic.get_input("Application already exists! Would you like to reinstall/overwrite?",
                                      ["r", "o", "n"], "n", ["Reinstall", "Overwrite", "Cancel"])  # Ask to reinstall
            if reinstall == "r":
                status = prog_manage.pre_install(args.install, False)
            elif reinstall == "o":
                status = prog_manage.pre_install(args.install, True)
                overwrite = True
            else:
                generic.pprint("Reinstall cancelled.")
        if status == "Installed" and not overwrite:
            install_wrap_up(config.name(args.install))
        elif status.startswith("No"):
            generic.pprint("{} needs to be installed! Installation halted.".format(status[3:]))
        elif status == "No rsync":
            generic.pprint("rsync not installed! Please install it!")
            exit_code = 1
        elif status == "Bad name":
            generic.pprint("Archive name cannot contain a space or #!")
            exit_code = 1
        elif status == "Error":
            generic.pprint("Error occured while extracting archive!")
            exit_code = 1

    elif args.gitinstall is not None:
        overwrite = False
        status = prog_manage.pre_gitinstall(args.gitinstall)
        if status == "No git":
            generic.pprint("git not installed! Please install it before using this feature!")
            exit_code = 1
        elif status == "Bad URL":
            generic.pprint("Invalid URL supplied; make sure it ends in .git!")
            exit_code = 1
        elif status == "Application exists":
            reinstall = generic.get_input("Application already exists! Would you like to reinstall/overwrite?",
                                            ["r", "o", "n"], "n", ["Reinstall", "Overwrite", "Cancel"])  # Ask to reinstall
            if reinstall == "r":
                status = prog_manage.pre_gitinstall(args.gitinstall, False)
            elif reinstall == "o":
                status = prog_manage.pre_gitinstall(args.gitinstall, True)
                overwrite = True
            else:
                generic.pprint("Reinstall cancelled.")
        if status == "Installed" and not overwrite:
            install_wrap_up(config.name(args.gitinstall))
        elif status == "No rsync":
            generic.pprint("rsync not installed! Please install it!")
            exit_code = 1
        elif status == "Error":
            generic.pprint("An error occured while attempting to git clone!")
            exit_code = 1
    

    elif args.singleinstall is not None:
        status = prog_manage.pre_singleinstall(args.singleinstall)
        if status == "Bad file":
            generic.pprint("The specified file does not exist!")
            exit_code = 1
        elif status == "Application exists":
            reinstall = generic.get_input("Application already exists! Would you like to reinstall?",
                                      ["r", "n"], "n", ["Reinstall", "Cancel"])  # Ask to reinstall
            if reinstall == "r":
                status = prog_manage.pre_singleinstall(args.singleinstall, True)
            else:
                generic.pprint("Reinstall cancelled.")
        if status == "Installed":
            install_wrap_up(config.name(args.singleinstall), True)
        elif status.startswith("No"):
            generic.pprint("{} needs to be installed! Installation halted.".format(status[3:]))
        elif status == "No rsync":
            generic.pprint("rsync not installed! Please install it!")
            exit_code = 1
        elif status == "Bad name":
            generic.pprint("Archive name cannot contain a space or #!")
            exit_code = 1
        elif status == "Error":
            generic.pprint("Error occured while extracting archive!")
            exit_code = 1


    elif args.dirinstall is not None:
        overwrite = False
        status = prog_manage.pre_dirinstall(args.dirinstall)
        if status == "Bad folder":
            generic.pprint("Please specify a valid directory path that ends in a \"/\"!")
            exit_code = 1
        elif status == "Application exists":
            reinstall = generic.get_input("Application already exists! Would you like to reinstall/overwrite?", ["r", "o", "n"], "n", 
            ["Reinstall", "Overwrite", "Cancel"])
            if reinstall == 'r':
                status = prog_manage.pre_dirinstall(args.dirinstall, False)
            elif reinstall == 'o':
                status = prog_manage.pre_dirinstall(args.dirinstall, True)
                overwrite = True
            else:
                generic.pprint("Reinstall cancelled.")
        if status == "Installed" and not overwrite:
            install_wrap_up(config.dirname(args.dirinstall))
        elif status == "No rsync":
            generic.pprint("rsync not installed! Please install it!")
            exit_code = 1

    elif args.remove is not None:
        status = prog_manage.uninstall(args.remove)
        if status == "Success":
            generic.pprint("Successfully uninstalled {}!".format(args.remove))
        elif status == "Not installed":
            generic.pprint("{} isn't an installed program!".format(args.remove))

    elif args.manage is not None:
        manage(args.manage)

    elif args.list:
        programs = prog_manage.list_programs()
        if programs == []:
            generic.pprint("No programs installed!")
        else:
            msg = ""
            for p in programs:
                msg += p + "\n"
            generic.pprint(msg)

    elif args.erase:
        erase_sure = generic.get_input("Are you sure you would like to remove tarstall from your system?",
                                    ['y', 'n'], 'n', ["Yes", "No"])
        if erase_sure == 'y':
            erase_really_sure = generic.get_input('Are you absolutely sure?' +
                                                'This will remove all programs installed with tarstall!',
                                                ['y', 'n'], 'n', ["Yes", "No"])
            if erase_really_sure == 'y':
                status = prog_manage.erase()
                if status == "Not installed":
                    generic.pprint("tarstall isn't installed, so not removed!")
                elif status == "Erased":
                    generic.pprint("tarstall has been removed! Please restart your terminal.")
                    sys.exit(0)
                elif status == "No line":
                    generic.pprint("tarstall has been removed!" + 
                    " Couldn't remove the line for tarstall's shell file. Your shell isn't supported, or the file couldn't be found!")
            else:
                generic.pprint('Erase cancelled.')
        else:
            generic.pprint('Erase cancelled.')

    elif args.verbose:
        status = prog_manage.verbose_toggle()
        generic.pprint("Verbose mode {}".format(status))

    elif args.update:
        status = prog_manage.update()
        process_update_status(status)

    elif args.config:
        configure()
    
    elif args.update_programs is True:
        status = prog_manage.update_programs()
        if status == "No git":
            generic.pprint("git isn't installed, please install it!")
            exit_code = 1
        elif status == "No programs":
            generic.pprint("You have no programs installed!")
            exit_code = 1
        else:
            msg = "Program Update Information:\n\n"
            exit_code = 0
            for p in status.keys():
                if status[p] == "Success":
                    msg += p + " updated successfully!\n"
                elif status[p] == "No update":
                    msg += p + " is already up to date!\n"
                elif status[p] == "OSError":
                    msg += p + " does not have #!/bin/sh or similar specified at the top of its file!\n"
                    exit_code = 1
                elif status[p] == "Does not update":
                    msg += p + " does not update or has a URL as its only update option!\n"
                else:
                    msg += p + " did not update successfully!\n"
                    exit_code = 1
            generic.pprint(msg)
    
    elif args.update_programs:
        if not args.update_programs in config.db["programs"]:
            generic.pprint("{} not installed!".format(args.update_programs))
            exit_code = 1
        else:
            update_program_gui(args.update_programs)


    elif not did_fts:
        generic.pprint("""
tarstall. A Python based package manager to manage archives.
Written by: hammy3502

tarstall Version: {user_version}
Internal Version Code: {file_version}.{prog_version}
Branch: {branch}

For help, type "tarstall -h"

For additional help, the tarstall wiki is linked below.

https://github.com/hammy3502/tarstall/wiki
        """.format(user_version=config.get_version("version"), file_version=config.get_version("file_version"),
                prog_version=config.get_version("prog_internal_version"), branch=config.branch))

    config.unlock()
    if mode == "gui":
        return
    elif mode == "cli":
        sys.exit(exit_code)


if __name__ == "__main__":
    if mode == "cli":
        parse_args()
    elif mode == "gui":
        gui_loop()